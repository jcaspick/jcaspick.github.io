<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jake Caspick</title>
    <link>http://www.jakecaspick.com/</link>
    <description>Recent content on Jake Caspick</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 11 Feb 2016 14:56:05 -0400</lastBuildDate>
    <atom:link href="http://www.jakecaspick.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>About</title>
      <link>http://www.jakecaspick.com/about/</link>
      <pubDate>Thu, 11 Feb 2016 14:56:05 -0400</pubDate>
      
      <guid>http://www.jakecaspick.com/about/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ZTower - My First HTML5 Game</title>
      <link>http://www.jakecaspick.com/post/ztower/</link>
      <pubDate>Thu, 11 Feb 2016 12:08:56 -0400</pubDate>
      
      <guid>http://www.jakecaspick.com/post/ztower/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;http://www.jakecaspick.com/img/ztower.png&#34; alt=&#34;ZTower&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is a simple game I wrote in the summer of 2015 when I was first learning Javascript.  I created it using the Phaser game library.  You can &lt;a href=&#34;https://jcaspick.github.io/ytower/&#34;&gt;play the game here&lt;/a&gt; and you can find the &lt;a href=&#34;https://github.com/jcaspick/ytower&#34;&gt;source code on GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Creating Infinite Tunnels With Raymarching</title>
      <link>http://www.jakecaspick.com/post/raymarching/</link>
      <pubDate>Thu, 11 Feb 2016 11:46:35 -0400</pubDate>
      
      <guid>http://www.jakecaspick.com/post/raymarching/</guid>
      <description>&lt;p&gt;I recently learned about an interesting technique for rendering 3D images, known as &lt;em&gt;raymarching distance fields&lt;/em&gt;.  This technique became popular in the demoscene for its power and simplicity.  It is capable of generating complexly detailed 3D images in real time with remarkably few lines of code.  An excellent explanation of how the algorithm works can be found &lt;a href=&#34;http://9bitscience.blogspot.ca/2013/07/raymarching-distance-fields_14.html&#34;&gt;here&lt;/a&gt; and many working examples can be found on &lt;a href=&#34;https://www.shadertoy.com/view/Xds3zN&#34;&gt;Shadertoy&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been writing a raymarcher in Processing.  This project has given me a more detailed understanding of the algorithm and a &lt;em&gt;lot&lt;/em&gt; of practice with vector math in 3D space.  Even in it&amp;rsquo;s current bare-bones state, it is capable of generating some really cool images.  The most fun use of the program that I&amp;rsquo;ve discovered is creating these infinite tunnel gifs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.jakecaspick.com/img/raymarch1.gif&#34; alt=&#34;raymarch1&#34; /&gt;
&lt;img src=&#34;http://www.jakecaspick.com/img/raymarch2.gif&#34; alt=&#34;raymarch2&#34; /&gt;
&lt;img src=&#34;http://www.jakecaspick.com/img/protoplasm.gif&#34; alt=&#34;protoplasm&#34; /&gt;
&lt;img src=&#34;http://www.jakecaspick.com/img/clockwerk.gif&#34; alt=&#34;clockwerk&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can view the source code &lt;a href=&#34;https://github.com/jcaspick/processing-raymarcher&#34;&gt;on GitHub&lt;/a&gt;.  I&amp;rsquo;ve tried to organize the code in a readable way, and written lots of comments explaining how the different parts work.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Global Game Jam 2016 - Writing a Procedural Maze Generator</title>
      <link>http://www.jakecaspick.com/post/gamejam2016/</link>
      <pubDate>Wed, 10 Feb 2016 11:38:08 -0400</pubDate>
      
      <guid>http://www.jakecaspick.com/post/gamejam2016/</guid>
      <description>

&lt;p&gt;This year I participated in the Global Game Jam at Volta Labs.&lt;/p&gt;

&lt;p&gt;The theme of the game jam was &lt;strong&gt;ritual&lt;/strong&gt;.  In our group brainstorm we thought of rituals as referring to repetitive behaviors and routines, which got us thinking about robots designed to perform specific functions, which ultimately led to an elaborate and whimsical game idea about amnesiac robots trying to rediscover their purpose.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.jakecaspick.com/img/dd1.png&#34; alt=&#34;Directile Dysfunction: A Search For Meaning&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Procedurally generated levels were part of the design of the game, and my role in the team was to write the level generator.  It later became apparent that our idea was over-ambitious (it wouldn&amp;rsquo;t be a game jam without a crash course in scope creep!)  My new mission was to take the code I had written so far and make a game out of it, trying to fit in as many elements of the original idea as possible.  The end result, just barely finished before the deadline, was a simple find-the-exit maze game starring a robot with an existential crisis.  You can download the game and Unity project &lt;a href=&#34;http://globalgamejam.org/2016/games/directile-dysfunction&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;What follows is a post-mortem of the things that worked, the things that didn&amp;rsquo;t work, and the lessons I learned from my game jam experience.&lt;/p&gt;

&lt;h1 id=&#34;the-challenge:d7fd8029c5ea5af11a17d471ecd44ec6&#34;&gt;The Challenge&lt;/h1&gt;

&lt;p&gt;Being mindful of the always-looming deadline, I chose a simple concept for the procedural level generator.  The game world would be a network of individual rooms connected by doors, and only one room would be shown on the screen at any given time, like the dungeons in the first Zelda games.&lt;/p&gt;

&lt;p&gt;The algorithm I wrote stored the game world in a two dimensional array.  Each element of that array was an instance of a &lt;code&gt;Room&lt;/code&gt; class which contained, among many other things, information about which other rooms it was connected to.  For every room in the array a compass direction was chosen at random and a connection was made to the neighboring room in that direction.  I thought that since every room had at least one connection, a path would therefore exist between any two rooms.  After that was done I wrote an ASCII display so I could see the worlds my algorithm was generating&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;the-problem:d7fd8029c5ea5af11a17d471ecd44ec6&#34;&gt;The Problem&lt;/h1&gt;

&lt;p&gt;Whoops.&lt;/p&gt;

&lt;p&gt;My hypothesis was wrong.  Rather than a single network of rooms, I got multiple isolated islands.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.jakecaspick.com/img/ddlevel1.png&#34; alt=&#34;level generator problem&#34; /&gt;
&lt;img src=&#34;http://www.jakecaspick.com/img/ddlevel2.png&#34; alt=&#34;level generator problem&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I realized now that what I was trying to write was, in essence, a maze generator.  I started reading about different ways of creating mazes and learned about Kruskal&amp;rsquo;s algorithm, Prim&amp;rsquo;s algorithm, and recursive backtracking. (lots of great information and code examples &lt;a href=&#34;http://weblog.jamisbuck.org/2011/2/7/maze-generation-algorithm-recap.html&#34;&gt;here&lt;/a&gt; if anybody is interested!)  Many browser tabs later I realized that I had fallen into a &lt;a href=&#34;https://xkcd.com/214/&#34;&gt;Nerd Vortex&lt;/a&gt;, that I wasn&amp;rsquo;t &lt;em&gt;really&lt;/em&gt; working on my code anymore, and that it was very late.&lt;/p&gt;

&lt;p&gt;I decided to sleep on it.&lt;/p&gt;

&lt;h1 id=&#34;the-solution:d7fd8029c5ea5af11a17d471ecd44ec6&#34;&gt;The Solution&lt;/h1&gt;

&lt;p&gt;My first plan was simply to create a connection linking each of the islands.  To do that I wrote a depth first search algorithm.  It worked recursively, calling itself on each neighbor of a starting room and finally returning a list of every room it found.  Now that I could identify each island, I could search for connections which would merge two islands together, and repeat that process until only one superisland remained.&lt;/p&gt;

&lt;p&gt;The problem was time.  I had already spent too much time generating and manipulating graphs of rooms, and there was still an entire game to build!  So I decided to use the code I already had for a quick and simple solution: use the largest island as the game world and discard the other islands.&lt;/p&gt;

&lt;p&gt;As a bonus, I also got the solution to another problem almost for free!  By making a small modification to the depth first search algorithm I could keep track of the recursion depth and attach that data to each room searched.  This meant I could pick the two rooms with the least and greatest depth to be the start and end points of the level, so you would never start the game right next to the goal.&lt;/p&gt;

&lt;h1 id=&#34;what-i-learned:d7fd8029c5ea5af11a17d471ecd44ec6&#34;&gt;What I Learned&lt;/h1&gt;

&lt;p&gt;Nobody loves the stress of having deadlines, but time constraints are ultimately good for creativity.  I have a tendency to be a perfectionist, which can bring my productivity to a standstill if I get lost in small details.  Given unlimited time, I probably would&amp;rsquo;ve started from scratch and tried to implement one of the maze algorithms I had learned about.  The deadline forced me to think differently and to keep moving.  Instead of seeing my algorithm as &lt;em&gt;wrong&lt;/em&gt; and rewriting it, I saw opportunities to make creative use of what I already had.&lt;/p&gt;

&lt;p&gt;The lesson I learned is summed up nicely by a poster on the wall at Volta: &amp;ldquo;done is better than perfect.&amp;rdquo;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>